# CSAPP Bomb lab

CSAPP的bomb lab是让你通过反汇编和gdb，找到六个相应的字符串，来拆掉炸弹。

本实验一共六个阶段，每个阶段对应一个字符串。在完成这六个阶段以后，还有一个彩蛋secret_phase。彩蛋可以在反汇编的代码中看到，只能通过gdb进入，没有出现在`main`函数中。

整个实验的整体框架可以在`bomb.c`文件中看到。主要是用的工具是gdb和objdump。

下面的代码都是在gdb中反汇编出来的代码，通过gdb反汇编出来的代码跳转地址是用的绝对地址，比较好看。



## Phase_1

```assembly 
phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq 
```

第一阶段是将输入的字符串与位于`0x402400`比较，如果相等则成功。函数`strings_not_equal`做的事情就是比较两个字符串，如果相等就返回0，反之返回1。

在`strings_not_equla`中首先调用`string_length`测量两个字符串的长度，不想等直接返回1，相等的话在逐一比对字符串中的字符，全部相等返回0。

答案就是储存在`0x402400`里面的字符：`Border relations with Canada have never been better.`



## Phase_2

```assembly
phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq   
```

第二阶段让我们输入六个数字，通过`read_six_numbers`，把输入的六个数字储存在栈中。并且第一个数字必须是1(代码`0x400f0a`)，然后通过一个循环(从`0x400f1a`到`0x400f2c`)来计算后一个数必须是前一个数的两倍，而且我们知道第一个数必须是1。所以答案是：`1 2 4 8 16 32`。



## Phase_3

```assembly
phase_3: 
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq   
```

第三阶段相当于一个`switch`结构，要输入两个数字，并切第一个数字不能大于7。第二个数字通过位于`0x400f75`的这条命令找到，这条命令的意思是，跳转到`0x402470(,%rax,8)`里面值的位置处。通过查看内存`0x402470`里面储存的值，我们很容易得到跳转后的地址。

内存`0x402470`处的地址如下:

```assembly
0x402470:       0x00400f7c      0x00000000      0x00400fb9      0x00000000
0x402480:       0x00400f83      0x00000000      0x00400f8a      0x00000000
0x402490:       0x00400f91      0x00000000      0x00400f98      0x00000000
0x4024a0:       0x00400f9f      0x00000000      0x00400fa6      0x00000000
```

答案有以下几个：

```
0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
```



## Phase_4

```assembly
phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    $0x2,%eax
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    callq  0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    retq  
```

第四阶段也是输入两个数字。首先通过`sscanf`读入两个数字放入`0x8(%rsp)`和`0xc(%rsp)`。并且第一个数字要小于等于`14`，第二个数字要等于`0`。我第一次尝试用`1 0`，加成功了，加没怎么仔细看`func4`。

答案就是:`1 0`。



## Phase_5

```assembly
phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    callq  0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   retq 
```

第五阶段输入的是一个长度为6的字符串，从地址`0x40108b`到`0x4010ac`是一个循环，通过将输入的字符的低八位作为索引，从地址`0x4024b0`中取出字符来放入到栈中(`0x10(%rsp)`)。然后将栈中的字符串与位于`0x40245e`的字符串比较，如果相等就通过。

地址`0x4024b0`存放的字符串是：`maduiersnfotvbyl`。

答案是：`ionefg`，在地址`0x40245e`里面的字符串是`flyers`。



## Phase_6

第六阶段的代码比较长，主要分成来一下几个阶段

- 将输入的六个数字放到栈中(`%rsp`)；

- 查看读入的六个数字，是否互不相等，并且在1，2，3，4，5，6中取值；
- 用7 - 输入的六个数字，覆盖原来存放在栈中(`%rsp`)的数字；
- 利用现在栈中(`%rsp`)的数字和地址`0x6032d0`处的内容，填充地址`0x20(%rsp)`到`0x50(%rsp)`；
- 然后利用地址`0x20(%rsp)`到`0x50(%rsp)`的数据，填充地址`0x6032d0`到`0x603320`处；
- 最后根据`0x6032d0`到`0x603320`，如下面所示

```assembly
0x6032d0 <node1>:       0x0000014c      0x00000001      0x00000000      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032d0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x006032e0      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x006032f0      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603300      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00603310      0x00000000
```

根据**每一行地址处第一个字的数值**和**以第三个字数值为地址的数值**相比，如果所以的第一个数大于第二个数，那么通过。举个例子，第二行的地址是`0x6032e0`，第一个字的数值是`0xa8`，第三个字的地址是`0x6032d0`，在`0x6032d0`处的数值是`0x14c`，比较`0x14c`和`0xa8`。这种比较地址`0x20(%rsp)`开始。

下面是栈和地址`0x6032d0`的变化：

```assembly
#输入的是1 2 3 4 5 6
#用7- 只有的栈
0x7fffffffe460: 0x00000006      0x00000005      0x00000004      0x00000003
0x7fffffffe470: 0x00000002      0x00000001      0x00000000      0x00000000
0x7fffffffe480: 0xffffe5c0      0x00007fff      0x00000000      0x00000000
0x7fffffffe490: 0x00000000      0x00000000      0x004013cc      0x00000000
0x7fffffffe4a0: 0xffffe5c8      0x00007fff      0x00603910      0x00000000

#开始的使用
0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000

#用数字填充后的栈
0x7fffffffe460: 0x00000006      0x00000005      0x00000004      0x00000003
0x7fffffffe470: 0x00000002      0x00000001      0x00000000      0x00000000
0x7fffffffe480: 0x00603320      0x00000000      0x00603310      0x00000000
0x7fffffffe490: 0x00603300      0x00000000      0x006032f0      0x00000000
0x7fffffffe4a0: 0x006032e0      0x00000000      0x006032d0      0x00000000

#反向填充后的结果
0x6032d0 <node1>:       0x0000014c      0x00000001      0x00000000      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032d0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x006032e0      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x006032f0      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603300      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00603310      0x00000000
```

在将数据中栈中填充后`0x6032d0`时，是有一定顺序的；以上面的结果举例，填充回去的时候是在`0x603320`哪里填充`0x603310`，接着在`0x603310`哪里填充`0x603300`，以此类推。。。

数据的比较也是按照上面的顺序，`0x603320`要大于`0x603310`，`0x603310`要大于`0x603300`。

所以我们只要使`0x6032d0`的处的地址填充到(`0x20(%rsp)`)时，按照数值从大到小的顺序就可以了

我们观察可得(省略前缀只用后两位)`f0 > 00 >10 > 20 > d0 > e0`。所以数字是`3 4 5 6 1 2`，在通过`7-`得到最终的答案`4 3 2 1 6 5`。 



## Secret_phase

```assembly
secret_phase:
   0x0000000000401242 <+0>:     push   %rbx
   0x0000000000401243 <+1>:     callq  0x40149e <read_line>
   0x0000000000401248 <+6>:     mov    $0xa,%edx
   0x000000000040124d <+11>:    mov    $0x0,%esi
   0x0000000000401252 <+16>:    mov    %rax,%rdi
   0x0000000000401255 <+19>:    callq  0x400bd0 <strtol@plt>
   0x000000000040125a <+24>:    mov    %rax,%rbx
   0x000000000040125d <+27>:    lea    -0x1(%rax),%eax
   0x0000000000401260 <+30>:    cmp    $0x3e8,%eax
   0x0000000000401265 <+35>:    jbe    0x40126c <secret_phase+42>
   0x0000000000401267 <+37>:    callq  0x40143a <explode_bomb>
   0x000000000040126c <+42>:    mov    %ebx,%esi
   0x000000000040126e <+44>:    mov    $0x6030f0,%edi
   0x0000000000401273 <+49>:    callq  0x401204 <fun7>
   0x0000000000401278 <+54>:    cmp    $0x2,%eax
   0x000000000040127b <+57>:    je     0x401282 <secret_phase+64>
   0x000000000040127d <+59>:    callq  0x40143a <explode_bomb>
   0x0000000000401282 <+64>:    mov    $0x402438,%edi
   0x0000000000401287 <+69>:    callq  0x400b10 <puts@plt>
   0x000000000040128c <+74>:    callq  0x4015c4 <phase_defused>
   0x0000000000401291 <+79>:    pop    %rbx
   0x0000000000401292 <+80>:    retq   
```

当我们通过objdump将bomb反汇编以后就会在phase_6，下面发现还有这么一个小彩蛋。

这个阶段是输入一个数字，然后调用`fun7`，如果返回值等于2，那就通过来，反之失败。主要就是`fun7`这个函数。`fun7`是一个递归函数，代码如下：

```assembly
fun7:
   0x0000000000401204 <+0>:     sub    $0x8,%rsp
   0x0000000000401208 <+4>:     test   %rdi,%rdi
   0x000000000040120b <+7>:     je     0x401238 <fun7+52>
   0x000000000040120d <+9>:     mov    (%rdi),%edx
   0x000000000040120f <+11>:    cmp    %esi,%edx
   0x0000000000401211 <+13>:    jle    0x401220 <fun7+28>
   0x0000000000401213 <+15>:    mov    0x8(%rdi),%rdi
   0x0000000000401217 <+19>:    callq  0x401204 <fun7>
   0x000000000040121c <+24>:    add    %eax,%eax
   0x000000000040121e <+26>:    jmp    0x40123d <fun7+57>
   0x0000000000401220 <+28>:    mov    $0x0,%eax
   0x0000000000401225 <+33>:    cmp    %esi,%edx
   0x0000000000401227 <+35>:    je     0x40123d <fun7+57>
   0x0000000000401229 <+37>:    mov    0x10(%rdi),%rdi
   0x000000000040122d <+41>:    callq  0x401204 <fun7>
   0x0000000000401232 <+46>:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401236 <+50>:    jmp    0x40123d <fun7+57>
   0x0000000000401238 <+52>:    mov    $0xffffffff,%eax
   0x000000000040123d <+57>:    add    $0x8,%rsp
   0x0000000000401241 <+61>:    retq   
```

在这个函数中有几个比较关键的地方，

- 在地址`0x40121c`，可以讲`%eax`加倍；
- 在地址`0x401220`，可以讲`%eax`清零；
- 在地址`0x40123d`，可以讲`%eax`变成`1`(前提`%eax`开始等于0)。

因为是递归调用，图中有两个地方可以进入递归，一个是`0x401217`，另一个是`0x40122d`。要想得到返回值是二，需要首先通过`0x401217`进入递归，然后通过`0x40122d`进入递归，最后通过`0x401227`处的代码返回。

要想实现上面的过程，就必须知道`%rdi(0x6030f0)`处，储存着什么。

```assembly
0x6030f0 <n1>:  0x00000024      0x00000000      0x00603110      0x00000000
0x603100 <n1+16>:       0x00603130      0x00000000      0x00000000      0x00000000
0x603110 <n21>: 0x00000008      0x00000000      0x00603190      0x00000000
0x603120 <n21+16>:      0x00603150      0x00000000      0x00000000      0x00000000
0x603130 <n22>: 0x00000032      0x00000000      0x00603170      0x00000000
0x603140 <n22+16>:      0x006031b0      0x00000000      0x00000000      0x00000000
0x603150 <n32>: 0x00000016      0x00000000      0x00603270      0x00000000
0x603160 <n32+16>:      0x00603230      0x00000000      0x00000000      0x00000000
0x603170 <n33>: 0x0000002d      0x00000000      0x006031d0      0x00000000
0x603180 <n33+16>:      0x00603290      0x00000000      0x00000000      0x00000000
0x603190 <n31>: 0x00000006      0x00000000      0x006031f0      0x00000000
0x6031a0 <n31+16>:      0x00603250      0x00000000      0x00000000      0x00000000
0x6031b0 <n34>: 0x0000006b      0x00000000      0x00603210      0x00000000
0x6031c0 <n34+16>:      0x006032b0      0x00000000      0x00000000      0x00000000
0x6031d0 <n45>: 0x00000028      0x00000000      0x00000000      0x00000000
0x6031e0 <n45+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x6031f0 <n41>: 0x00000001      0x00000000      0x00000000      0x00000000
0x603200 <n41+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x603210 <n47>: 0x00000063      0x00000000      0x00000000      0x00000000
0x603220 <n47+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x603230 <n44>: 0x00000023      0x00000000      0x00000000      0x00000000
0x603240 <n44+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x603250 <n42>: 0x00000007      0x00000000      0x00000000      0x00000000
0x603260 <n42+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x603270 <n43>: 0x00000014      0x00000000      0x00000000      0x00000000
0x603280 <n43+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x603290 <n46>: 0x0000002f      0x00000000      0x00000000      0x00000000
0x6032a0 <n46+16>:      0x00000000      0x00000000      0x00000000      0x00000000
0x6032b0 <n48>: 0x000003e9      0x00000000      0x00000000      0x00000000
```

于是我们可以得到，输入的数字是`22`。













































